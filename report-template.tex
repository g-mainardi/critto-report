\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

\usepackage{amssymb}
\usepackage{amsmath}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

%\linespread{1.25} % Imposta l'interlinea di x volte la dimensione del carattere

\title{Teoria dei numeri \\ applicata alla Crittografia}

\author{Giosuè Giocondo Mainardi\\ (n.0000933566)}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\chapter{Introduzione}
La \textbf{crittografia} è fondamentale per garantire la sicurezza delle comunicazioni digitali, proteggendo la \emph{confidenzialità, l'integrità e l'autenticità} dei dati scambiati. 
Molti degli algoritmi crittografici più diffusi e robusti si basano su solidi principi matematici derivanti dalla \textbf{teoria dei numeri}. 

Sebbene in passato crittografia e matematica fossero viste come discipline separate, con \emph{G.H. Hardy} che nel 1940 vedeva la matematica come una scienza neutra, pura e gentile,
che non si schiera e non ha applicazioni dirette, l'avvento dell'informatica ha dimostrato il loro stretto legame. 

La teoria dei numeri, con lo studio delle proprietà dei numeri interi, dei \textbf{numeri primi} e delle loro interazioni, è diventata un pilastro portante per lo sviluppo di sistemi crittografici sicuri.

La \textbf{fattorizzazione in numeri primi}, il \textbf{logaritmo discreto} e le \textbf{equazioni diofantee} sono solo alcuni dei concetti chiave della teoria dei numeri che trovano 
applicazione nella crittografia moderna. Algoritmi rivoluzionari come \emph{RSA} e \emph{Diffie-Hellman}, basilari per la crittografia a chiave pubblica, sfruttano questi principi 
per garantire elevati livelli di sicurezza. La casualità è una caratteristica fondamentale in crittografia, eppure, come sottolineava \emph{Von Neumann}, 
``Chiunque consideri metodi aritmetici per produrre cifre casuali è, ovviamente, in stato di peccato'', evidenziando l'impossibilità di ottenere vera casualità in aritmetica. 
Tuttavia, la teoria dei numeri offre proprietà ideali per nascondere e proteggere informazioni, come la difficoltà nel risolvere alcuni problemi aritmetici nonostante la loro apparente semplicità.

In questa relazione, esploreremo nel dettaglio il legame inscindibile tra crittografia e teoria dei numeri, analizzando le principali applicazioni di quest'ultima nella protezione dei dati digitali. 
Verranno approfonditi concetti come la fattorizzazione, il logaritmo discreto e le equazioni diofantee, al fine di comprendere appieno il \textbf{ruolo cruciale} svolto dalla matematica nella \textbf{sicurezza informatica}.
%
%
%
%
\chapter{Fondamenti della teoria dei numeri}
È importante fornire prima basi teoriche matematiche per comprendere il funzionamento degli algoritmi che andremo a trattare.

La teoria dei numeri è lo studio dei numeri interi, e delle loro proprietà. L'insieme dei numeri interi è $\mathbb{Z}$ e contiene tutti i numeri interi positivi e negativi, insieme allo zero.
\begin{quote}
	\centering
	..., -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5, ...
\end{quote}

\section{Definizioni}

\subsection*{Numero primo}
Un numero primo è un numero intero \( p > 1 \) che ha esattamente due divisori: 1 e \(p\) (se stesso).

\textbf{Esempi}: ogni numero a sinistra nella seguente tabella è primo.
\[\begin{array}{ll}
3 & = 2 + 1 \\
7 & = 2 \cdot 3 + 1 \\
31 & = 2 \cdot 3 \cdot 5 + 1 \\
211 & = 2 \cdot 3 \cdot 5 \cdot 7 + 1 \\
2311 & = 2 \cdot 3 \cdot 5 \cdot 7 \cdot 11 + 1 \\
\end{array}\]
Questo schema non continua indefinitamente, ma qualcosa di simile funziona.

Occorre però ricordare che Euclide ha dimostrato che esistono infiniti numeri primi. \cite{stein2008}

Inoltre, si fa notare che il più grande numero primo conosciuto\footnote{Largest Know Prime Number:7 dicembre 2018 da Patrick Laroche} è \[2^{82,589,933} - 1\]
e ha quasi 25 milioni di cifre.

\subsection*{Numero composto}
Un numero composto è un numero intero \( n > 1 \) che ha almeno un altro divisore, oltre 1 e \( n \) (se stesso).

\section{Concetti Fondamentali}
\subsection*{Fattorizzazione}
La fattorizzazione è il processo di scomposizione di un numero intero \( n \) in un prodotto di numeri primi. 

\textbf{Formalmente}: dato un numero intero \( n \), la fattorizzazione di \( n \) è data dalla rappresentazione: 

\[ n = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_k^{e_k} \]

dove \( p_1, p_2, \ldots, p_k \) sono numeri primi distinti e \( e_1, e_2, \ldots, e_k \) sono esponenti positivi.

\subsection*{Divisibilità e criteri di divisibilità}

Un numero \(a\) è divisibile per un numero \(b\) se il resto della divisione di \(a\) per \(b\) è zero. In altre parole, se esiste un numero intero \(k\) tale che \(a = b \cdot k\), allora \(a\) è divisibile per \(b\).

Alcuni criteri di divisibilità comuni sono:
\begin{itemize}
	\item \textbf{Criterio della divisibilità per 2}: Un numero è divisibile per 2 se la sua ultima cifra è pari, cioè se termina con 0, 2, 4, 6 o 8.
	
	\item \textbf{Criterio della divisibilità per 3}: Un numero è divisibile per 3 se la somma delle sue cifre è divisibile per 3.
	
	\item \textbf{Criterio della divisibilità per 5}: Un numero è divisibile per 5 se termina con 0 o 5.
	
	\item \textbf{Criterio della divisibilità per 7}: Un numero è divisibile per 7 se il numero ottenuto sottraendo dal doppio della cifra delle unità il numero ottenuto togliendo la cifra delle unità è divisibile per 7.

	\item \textbf{Criterio della divisibilità per 11}: Un numero è divisibile per 11 se la differenza tra la somma delle cifre in posizione pari e la somma delle cifre in posizione dispari è un multiplo di 11(compreso lo 0).

\end{itemize}

\subsection*{Massimo comune divisore (MCD)}
Il massimo comune divisore di due numeri interi \( a \) e \( b \), denotato come 
\[ \mathbb{MCD}(a, b) \] 
ed è il più grande numero intero che divide entrambi \( a \) e \( b \) senza lasciare resto.

\subsection*{Minimo comune multiplo (mcm)}
Il minimo comune multiplo di due numeri interi \( a \) e \( b \), denotato come 
\[ \mathrm{mcm}(a, b) \]
ed è il più piccolo multiplo comune di \( a \) e \( b \).

\subsection*{Numeri coprimi}
Due numeri interi sono definiti come \textbf{coprimi} (o primi tra loro) se il loro massimo comune divisore (MCD) è uguale a 1. 

\textbf{Formalmente}: dati due numeri interi \(a\) e \(b\), essi sono coprimi se e solo se:
\[\mathbb{MCD}(a, b) = 1\]

\chapter{Aritmetica Modulare}

L'aritmetica modulare è un ramo fondamentale della teoria dei numeri che studia le operazioni aritmetiche sui resti delle divisioni intere. Questo capitolo esplora i concetti chiave dell'aritmetica modulare necessari per comprendere molti algoritmi crittografici moderni.

\section{Definizioni} 
\subsection*{Operatore modulo} Dato un numero intero $a$ e un modulo $n$, numero intero positivo, il "resto della divisione di $a$ per $n$" è il valore che rimane quando $a$ è diviso per $n$. Questo valore è sempre compreso tra 0 e $n-1$, inclusi.

Simbolicamente, possiamo esprimere il resto della divisione di $a$ per $n$ come:

\[ a \mod n \]

dove "mod" è l'operatore modulo.

\subsection*{Insieme modulo \( \mathbb{Z}_n\)}
Si sceglie un numero intero positivo \(n\), chiamato modulo, che determina l'insieme dei resti modulo \(n\). 
Questo insieme è denotato come \(\mathbb{Z}_n\)  , ed è composto da tutti i numeri interi che vanno da 0 a \(n-1\).

\textbf{Formalmente}: \[\mathbb{Z}_n = \{0, 1, 2, \ldots, n-1\}\]

\subsection*{Gruppo moltiplicativo \(\mathbb{Z}_n^*\)}
Un insieme modulo che contiene solo numeri coprimi rispetto al modulo dato è noto come gruppo moltiplicativo modulo \(n\), indicato con \(\mathbb{Z}_n^*\) o \((\mathbb{Z}/n\mathbb{Z})^*\). 
Questo gruppo è composto da tutti gli interi positivi minori di \(n\) che sono coprimi con \(n\).

\textbf{Formalmente}: \[\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n : \text{MCD}(a, n) = 1\}\]

\subsection*{Funzione Totiente di Eulero} \label{sec:totiente}
La funzione totiente di Eulero, indicata con $\phi(n)$, conta il numero di interi positivi minori o uguali a $n$ che sono coprimi con $n$, ovvero che non hanno fattori comuni con $n$ eccetto $1$. 

\textbf{Formalmente}:\[\phi(n) = |\{a \in \mathbb{Z}_n : \mathbb{MCD}(a, n) = 1\}| = |\mathbb{Z}_n^*|\]
\section{Congruenza Modulare}

Data una coppia di interi $a$ e $b$, e un intero positivo $n$ detto \textbf{modulo}, diciamo che $a$ è congruo a $b$ modulo $n$, denotato come:

$$a \equiv b \pmod{n}$$

Se esistono interi $k_1$ e $k_2$ tali che:

$$a = k_1n + b$$
$$b = k_2n + a$$

In altre parole, $a$ e $b$ hanno lo stesso resto quando divisi per $n$. 

\subsection*{Classe di Resto}
L'insieme di tutti gli interi congrui a $a$ modulo $n$ è chiamato \textbf{classe di resto} o \textbf{classe di congruenza} di $a$ modulo $n$, denotata come \[[a]_n\]

\subsection*{Proprietà}
La relazione di congruenza gode delle seguenti proprietà:

\begin{enumerate}
    \item \textbf{Riflessività}: $a \equiv a \pmod{n}$ per ogni $a \in \mathbb{Z}$ e $n > 0$.
    \item \textbf{Simmetria}: Se $a \equiv b \pmod{n}$, allora $b \equiv a \pmod{n}$.
    \item \textbf{Transitività}: Se $a \equiv b \pmod{n}$ e $b \equiv c \pmod{n}$, allora $a \equiv c \pmod{n}$.
\end{enumerate}

\section{Operazioni Aritmetiche Modulari}
Le operazioni aritmetiche fondamentali (addizione, sottrazione, moltiplicazione ed esponenziazione) possono essere definite sull'insieme dei residui modulo $n$, denotato come $\mathbb{Z}_n$. Per $a, b \in \mathbb{Z}_n$:

\begin{enumerate}
    \item \textbf{Addizione modulare}:
    $$(a + b) \bmod n = r \quad \text{dove } r \in \mathbb{Z}_n \text{ è il resto della divisione di } a+b \text{ per } n$$
    
    \item \textbf{Sottrazione modulare}:
    $$(a - b) \bmod n = r \quad \text{dove } r \in \mathbb{Z}_n \text{ è il resto della divisione di } a-b \text{ per } n$$
    
    \item \textbf{Moltiplicazione modulare}:
    $$(a \cdot b) \bmod n = r \quad \text{dove } r \in \mathbb{Z}_n \text{ è il resto della divisione di } a \cdot b \text{ per } n$$
    
    \item \textbf{Esponenziazione modulare}:
    $$a^b \bmod n = r \quad \text{dove } r \in \mathbb{Z}_n \text{ è il resto della divisione di } a^b \text{ per } n$$
\end{enumerate}

Queste operazioni godono delle stesse proprietà dell'aritmetica ordinaria: commutativà per addizione e moltiplicazione, associatività, elementi neutri (0 per addizione, 1 per moltiplicazione) e inversi (modulo $n$).

\section{Inverso Moltiplicativo Modulare}

Un concetto cruciale è quello di \textbf{elemento invertibile modulo $n$}: 

un numero $a \in \mathbb{Z}_n$ è invertibile se esiste $b \in \mathbb{Z}_n$ tale che $ab \equiv 1 \pmod{n}$. $b$ è detto l'\textbf{inverso moltiplicativo} di $a$ modulo $n$, denotato come $a^{-1}$.

\subsection*{Esistenza dell'Inverso Moltiplicativo}
L'inverso moltiplicativo di $a$ modulo $n$ esiste se e solo se $a$ e $n$ sono coprimi, ovvero il loro massimo comune divisore $\mathbb{MCD}(a,n) = 1$. 

\subsection*{Calcolo dell'Inverso Moltiplicativo} \label{sec:inverso}
L'inverso moltiplicativo di $a$ modulo $n$ si può calcolare efficacemente tramite l'algoritmo euclideo esteso e che sfrutta l'equazione di Bezout:
\[ ax+ny=1 \]
In cui $x$ è l'inverso moltiplicativo di $a$ modulo $n$.

\section{Aritmetica Modulare sui Numeri Primi}

Le proprietà dell'aritmetica modulare si semplificano notevolmente quando il modulo $n$ è un numero primo $p$. In questo caso, l'insieme $\mathbb{Z}_p$ è un \textbf{campo}, ovvero ogni elemento non nullo è invertibile (\( |\mathbb{Z}_p| =|\mathbb{Z}_p^*| \)).

\subsubsection*{Piccolo Teorema di Fermat}
Espressione generale:
$$a^p \equiv a \pmod{p} \quad \forall a \in \mathbb{Z}$$

Questo significa che elevare un numero $a$ alla potenza $p$ modulo $p$ dà come risultato $a$ stesso.

È spesso espresso nella forma equivalente, con \(a\) che è un intero coprimo con \(p\):

\[a^{p-1} \equiv 1 \pmod{p}\quad,\quad con\quad \mathbb{MCD}(a,p)=1\]

\subsubsection*{Teorema di Eulero (Fermat generalizzato)}

$$a^{\phi(n)} \equiv 1 \pmod{n} \quad \text{se } \mathbb{MCD}(a,n) = 1$$

Dove $\phi(n)$ è la \textbf{funzione totiente di Eulero}, che conta il numero di interi positivi minori di $n$ e coprimi con $n$.

\subsubsection*{Test di Primalità di Fermat} \label{sec:fermat}
Se $p$ è un numero primo e $a$ è un intero tale che $1 < a < p$, allora
\[a^{p-1} \equiv 1 \pmod{p}\]


%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
\chapter{Il Cifrario RSA}

\section{Introduzione}
Il cifrario RSA, introdotto dai crittografi Ron Rivest, Adi Shamir e Leonard Adleman nel 1977, rappresenta uno dei più importanti e diffusi algoritmi crittografici a chiave pubblica. 
Esso sfrutta le proprietà della teoria dei numeri e dell'aritmetica modulare per garantire la sicurezza delle comunicazioni. 
A differenza dei sistemi crittografici a chiave simmetrica, in cui la stessa chiave viene utilizzata per cifrare e decifrare i messaggi, il cifrario RSA utilizza due chiavi diverse, una pubblica e una privata.

\section{Principi Fondamentali}
Il cifrario RSA si basa su due principi fondamentali:

\begin{enumerate}
    \item La \textbf{difficoltà computazionale} di fattorizzare grandi numeri interi composti. Questo problema, noto come "problema della fattorizzazione intera", è uno dei problemi più difficili in teoria dei numeri e in crittografia. Anche se non è stato dimostrato essere NP-hard\footnote[1]{NP-hard significa che un problema è almeno tanto difficile quanto il problema più difficile in NP (nondeterministic polynomial time).}, non si conosce alcun algoritmo efficiente in grado di risolverlo in tempi ragionevoli per numeri sufficientemente grandi.
    \item La \textbf{facilità relativa di calcolare esponenziali modulari}, operazione che sta alla base del processo di cifratura e decifratura. Infatti, questa può essere eseguita in modo efficiente tramite tecniche come l'esponenziazione veloce.
\end{enumerate}

\section{Generazione delle Chiavi}
La generazione delle chiavi nel cifrario RSA segue i seguenti passi:

\begin{enumerate}
    \item Scegliere due numeri primi distinti $p$ e $q$ di grandi dimensioni.
    \item Calcolare $n = p \cdot q$, dove $n$ è chiamato modulo. La dimensione di $n$ determina la sicurezza del sistema crittografico.
    \item Calcolare $\phi(n) = (p - 1)(q - 1)$, dove $\phi$ è la funzione totiente di Eulero, vedi \ref{sec:totiente}.
    \item Scegliere un numero intero $e$ tale che $1 < e < \phi(n)$ e $\operatorname{MCD}(e, \phi(n)) = 1$. Il numero $e$ è chiamato esponente di cifratura. Tipicamente, si sceglie un valore piccolo per $e$, come $65537$ \footnote{Numero primo ha pochi bit impostati a 1, cosa che velocizza l'elaborazione}, per rendere più efficienti le operazioni di cifratura.
    \item Determinare $d$ tale che $d \cdot e \equiv 1 \pmod{\phi(n)}$. Il numero $d$ è chiamato esponente di decifratura. Esso può essere calcolato usando l'algoritmo di Euclide esteso, come specificato in \ref{sec:inverso}.
\end{enumerate}

La coppia $(e, n)$ rappresenta la chiave pubblica, mentre $(d)$ è la chiave privata. La chiave pubblica può essere ampiamente diffusa, mentre la chiave privata deve essere mantenuta segreta.

\subsection*{Determinazione dei numeri primi}
La scelta dei due numeri primi $p$ e $q$ è cruciale per garantire la sicurezza del cifrario RSA. 
Essi devono essere scelti in modo casuale e devono essere di dimensioni sufficientemente grandi per resistere a potenziali attacchi di forza bruta o di fattorizzazione.
I passi per la generazione di un numero primo "forte":

\begin{itemize}
    \item{Scelta della \textbf{dimensione} (n°bit).}
    \item{\textbf{Generazione Casuale} del numero.} 
    \item{\textbf{Verifica della Primalità}: ci sono diversi Test per verificare che il numero generato sia effettivamente primo, vedi Test di Fermat in \ref{sec:fermat}.}
    \item{\textbf{Ripetizione}: Se il numero generato non è primo, si ripete il processo di generazione fino a ottenere un numero primo valido.}
    \item{\textbf{Utilizzo di Numeri Primi Sicuri}: sono considerati "safeprimes" i numeri primi di Sophie Germain: dato $p$ primo, è considerato safe se anche \(2p+1\) è primo. \cite{boneh2005}}
\end{itemize}

\subsection*{Specifiche Attuali della Lunghezza delle Chiavi RSA}

Ecco le specifiche attuali per la lunghezza delle chiavi RSA:

\begin{itemize}
    \item \textbf{1024 bit}: Considerata insicura per la maggior parte degli scopi. Non è più raccomandata per l'uso.
    \item \textbf{2048 bit}: Attualmente considerata sicura per la maggior parte degli scopi. Raccomandata per molti utilizzi.
    \item \textbf{3072 bit}: Fornisce un margine di sicurezza maggiore, utilizzata per esigenze di sicurezza più elevate.
    \item \textbf{4096 bit}: Utilizzata per esigenze di sicurezza molto elevate, anche se comporta operazioni più lente.
\end{itemize}

Queste raccomandazioni sono in linea con le linee guida fornite da organizzazioni come il NIST (National Institute of Standards and Technology)\cite{nist}.

\section{Cifratura e Decifratura}
Sia $m$ il messaggio in chiaro, rappresentato come un numero intero nel range $[0, n - 1]$. Per trasformare il messaggio in un numero intero, si possono utilizzare varie tecniche di codifica, come la rappresentazione ASCII o Unicode dei caratteri.

\begin{enumerate}
    \item La cifratura avviene calcolando $c \equiv m^e \pmod{n}$, dove $c$ è il testo cifrato.
    \item La decifratura avviene calcolando $m \equiv c^d \pmod{n}$.
\end{enumerate}

La sicurezza del cifrario RSA risiede nella difficoltà computazionale di fattorizzare $n$ in $p$ e $q$, dato che la conoscenza di $p$ e $q$ permette di calcolare $\phi(n)$ e quindi la chiave privata $d$. Pertanto, la scelta di numeri primi $p$ e $q$ sufficientemente grandi è cruciale per garantire la sicurezza del sistema.

\section{Applicazioni e Considerazioni sulla Sicurezza}
Il cifrario RSA trova applicazione in numerosi contesti, come la crittografia dei dati, la firma digitale, lo scambio di chiavi e l'autenticazione. Esso è ampiamente utilizzato in diversi protocolli di sicurezza, come SSL/TLS, PGP e molti altri.

Tuttavia, è importante sottolineare che la sicurezza del cifrario RSA basandosi sulla difficoltà di fattorizzare grandi numeri interi composti, con l'avanzamento della potenza di calcolo dei computer e lo sviluppo di nuovi algoritmi di fattorizzazione, potrebbe diventare necessario aumentare le dimensioni delle chiavi per mantenere un adeguato livello di sicurezza.

Inoltre, esistono altre potenziali vulnerabilità legate all'implementazione del cifrario RSA, come la scelta di numeri primi deboli, la gestione non sicura delle chiavi private e la possibilità di attacchi side-channel. Pertanto, è fondamentale seguire le best practice di sicurezza e utilizzare implementazioni affidabili e constantemente aggiornate del cifrario RSA.

\section{RSA a Chiave Multipla}

Il cifrario RSA a chiave multipla è un'estensione dell'algoritmo RSA standard progettata per consentire la cifratura di messaggi destinati a più destinatari utilizzando una singola chiave privata. In questa sezione, esploreremo le principali differenze e aggiunte rispetto a RSA standard.

\subsection{Generazione delle Chiavi}

Nel RSA a chiave multipla, vengono generate più coppie di chiavi pubbliche/ private, una per ogni destinatario. Sia \( (N_i, e_i, d_i) \) la \( i \)-esima coppia di chiavi generate, dove \( N_i \) è il modulo, \( e_i \) è l'esponente pubblico e \( d_i \) è l'esponente privato. Questo richiede una procedura di generazione delle chiavi più complessa rispetto alla generazione di una singola coppia di chiavi.

\subsection{Cifratura dei Messaggi}

Il mittente utilizza la propria chiave privata \( d_S \) per cifrare il messaggio \( M \). Il messaggio cifrato \( C \) viene quindi cifrato separatamente utilizzando la chiave pubblica \( (N_i, e_i) \) di ciascun destinatario \( i \), generando \( C_i \). Formalmente:

\[C_i = (C^{e_i} \mod N_i)\]

\subsection{Decifratura dei Messaggi}

Ogni destinatario utilizza la propria chiave privata \( d_i \) per decifrare il messaggio cifrato \( C_i \) utilizzando la formula:
\[M = (C_i^{d_i} \mod N_i)\]

In questo modo, solo il destinatario corretto sarà in grado di decifrare il messaggio.

\subsection{Vantaggi e Considerazioni}

L'RSA a chiave multipla offre una maggiore flessibilità e sicurezza rispetto alla cifratura RSA standard, consentendo di inviare messaggi cifrati a più destinatari utilizzando una sola chiave privata. Tuttavia, richiede una gestione più complessa delle chiavi e può essere soggetto a sfide legate alla sicurezza, come la corretta autenticazione dei destinatari.

In conclusione, l'RSA a chiave multipla è una potente estensione dell'algoritmo RSA standard, che offre un'opzione efficace per la cifratura di dati destinati a più destinatari in un contesto crittografico.

\section{Estensioni e Miglioramenti}
Nel corso degli anni, sono state proposte diverse estensioni e miglioramenti al cifrario RSA originale, come:

\subsection{RSA a Chiave Multipla}
Il sistema RSA a chiave multipla consente di utilizzare più di due chiavi per cifrare e decifrare i messaggi, aumentando la sicurezza e la flessibilità del sistema. In questo schema, viene generato un insieme di $t$ chiavi pubbliche $(e_1, n_1), (e_2, n_2), \ldots, (e_t, n_t)$ e un'unica chiave privata $d$ condivisa.

La cifratura avviene calcolando:
\[c \equiv m^{e_1 e_2 \cdots e_t} \pmod{n_1 n_2 \cdots n_t}\]

Mentre la decifratura si ottiene calcolando:
\[m \equiv c^d \pmod{n_1 n_2 \cdots n_t}\]

Questo schema offre una maggiore sicurezza rispetto al RSA tradizionale, in quanto un potenziale attaccante dovrebbe fattorizzare il prodotto di tutti i moduli $n_i$ per compromettere il sistema. Inoltre, consente una maggiore flessibilità nella gestione delle chiavi pubbliche.

\subsection{RSA a Esponente Piccolo}
Il RSA a esponente piccolo è una variante che utilizza esponenti di cifratura e decifratura molto piccoli, come $3$ o $17$, al fine di migliorare le prestazioni delle operazioni di cifratura e decifratura. Questo approccio sfrutta la proprietà:
\[m^{e_1 e_2} \equiv (m^{e_1})^{e_2} \pmod{n}\]

Pertanto, la cifratura avviene calcolando $c \equiv m^{e_1} \pmod{n}$, mentre la decifratura richiede due passi:
\begin{align*}
x &\equiv c^{e_2} \pmod{n} \\
m &\equiv x^d \pmod{n}
\end{align*}

Sebbene l'utilizzo di esponenti piccoli riduca il costo computazionale delle operazioni, esistono potenziali vulnerabilità legate alla distribuzione dei messaggi cifrati e alla possibilità di attacchi a testo cifrato scelto.

\subsection{RSA con Funzione di Padding}
Le funzioni di padding vengono utilizzate per rendere il cifrario RSA più sicuro e compatibile con vari standard crittografici. Esse consistono nell'aggiungere bit ridondanti al messaggio prima della cifratura, al fine di prevenire attacchi come quello a testo cifrato scelto.

Uno schema di padding comune è OAEP (Optimal Asymmetric Encryption Padding), che utilizza una funzione di hash crittografica e una funzione di mascheramento per aumentare la sicurezza del messaggio cifrato. Un altro schema diffuso è PKCS\#1 v1.5, che aggiunge bit casuali e una struttura specifica al messaggio.

L'utilizzo di funzioni di padding appropriate è fondamentale per garantire la sicurezza del cifrario RSA e prevenire potenziali vulnerabilità legate all'input dei messaggi.

\subsection{RSA con Cifratura a Blocchi}
Poiché l'operazione di cifratura del RSA può essere applicata solo a messaggi di dimensione inferiore al modulo $n$, è necessario suddividere i messaggi più lunghi in blocchi prima della cifratura. Ogni blocco viene quindi cifrato separatamente utilizzando la chiave pubblica.

Esistono diverse modalità di cifratura a blocchi, come ECB (Electronic Code Book), CBC (Cipher Block Chaining), CFB (Cipher Feedback) e OFB (Output Feedback). Queste modalità introducono una dipendenza tra i blocchi cifrati, al fine di prevenire potenziali vulnerabilità legate alla cifratura a blocchi.

La scelta della modalità di cifratura a blocchi dipende dalle esigenze di sicurezza e dalle caratteristiche del canale di comunicazione. Ad esempio, la modalità CBC offre una maggiore sicurezza rispetto a ECB, ma richiede un vettore di inizializzazione casuale.

\subsection{RSA con Firma Digitale}
Il cifrario RSA può essere utilizzato non solo per la cifratura dei messaggi, ma anche per la generazione di firme digitali. Questo processo consente di garantire l'autenticità e l'integrità dei dati trasmessi.

La firma digitale di un messaggio $m$ viene calcolata come:
\[s \equiv m^d \pmod{n}\]

Dove $d$ è la chiave privata del firmatario. La verifica della firma avviene calcolando:
\[m \equiv s^e \pmod{n}\]

E confrontando il risultato con il messaggio originale. Esistono vari schemi di firma digitale basati su RSA, come PKCS\#1 v1.5 e PSS (Probabilistic Signature Scheme), che introducono ulteriori precauzioni per prevenire potenziali attacchi.

\subsection{RSA con Crittografia Ibrida}
La crittografia ibrida combina il cifrario RSA con algoritmi di crittografia simmetrica, sfruttando i punti di forza di entrambi i sistemi. In questo schema, RSA viene utilizzato per cifrare una chiave simmetrica casuale, che a sua volta viene impiegata per cifrare il messaggio vero e proprio con un algoritmo simmetrico più efficiente.

\sloppy
Questo approccio offre diversi vantaggi, come una maggiore efficienza nelle operazioni di cifratura e decifratura dei dati, una migliore gestione delle chiavi e una maggiore sicurezza complessiva del sistema. 
Esempi di schemi ibridi includono PGP (Pretty Good Privacy) e S/MIME (Secure/Multipurpose Internet Mail Extensions).

\subsection{Ottimizzazioni e Implementazioni Efficienti}
Per migliorare le prestazioni del cifrario RSA, sono state sviluppate diverse tecniche di ottimizzazione e implementazioni efficienti. Queste includono:

\begin{itemize}
   \item Algoritmi di esponenziazione veloce: consentono di calcolare esponenziali modulari in modo più efficiente, riducendo il numero di moltiplicazioni richieste.
   \item Ottimizzazioni hardware e software: sfruttano le caratteristiche dei processori e dei sistemi operativi per accelerare le operazioni aritmetiche modulari.
   \item Librerie e implementazioni open source: forniscono implementazioni sicure e ottimizzate del cifrario RSA, spesso integrate in framework crittografici più ampi.
\end{itemize}

Queste ottimizzazioni sono fondamentali per rendere il cifrario RSA praticabile in applicazioni real-world che richiedono prestazioni elevate e una gestione efficiente delle risorse computazionali.

\begin{itemize}
    \item RSA a chiave multipla: consente di utilizzare più di due chiavi per cifrare e decifrare i messaggi, aumentando la sicurezza e la flessibilità del sistema.
    \item RSA a esponente piccolo: utilizza esponenti di cifratura e decifratura molto piccoli (come $3$ o $17$) per migliorare le prestazioni delle operazioni di cifratura e decifratura.
    \item RSA a chiave corta: utilizza chiavi più corte (come $256$ bit) per ridurre i tempi di calcolo e la complessità computazionale, a discapito della sicurezza.
    \item RSA a chiave omomorfica: consente di eseguire operazioni aritmetiche sui dati cifrati senza decifrarli, aprendo nuove possibilità per la privacy e la sicurezza dei dati.
    \item RSA a chiave quantistica: sfrutta i principi della computazione quantistica per garantire una sicurezza ancora maggiore contro attacchi crittografici basati sulla fattorizzazione di numeri interi.
    \item RSA a chiave post-quantistica: sviluppa algoritmi crittografici resistenti ai futuri attacchi quantistici, garantendo una protezione a lungo termine dei dati.
    \item RSA a chiave ibrida: combina il cifrario RSA con altri algoritmi crittografici a chiave simmetrica o asimmetrica per ottenere un sistema crittografico più efficiente e sicuro.
    \item RSA a chiave distribuita: suddivide la chiave privata tra più entità, rendendo più difficile per un singolo attaccante recuperare l'intera chiave.
    \item RSA a chiave cieca: consente a un'entità di cifrare i dati senza conoscere la chiave pubblica dell'altra entità, garantendo la privacy e la sicurezza dei dati.
    \item RSA a chiave condivisa: utilizza una chiave condivisa tra le entità per cifrare e decifrare i messaggi, semplificando la gestione delle chiavi e migliorando le prestazioni del sistema.
    \item RSA a chiave zero-knowledge: consente a un'entità di dimostrare la conoscenza di una chiave privata senza rivelarla, garantendo la sicurezza e la privacy dei dati.
    \item RSA a chiave quantistica resistente ai rumori: sviluppa algoritmi crittografici resistenti ai rumori quantistici, garantendo una protezione affidabile contro gli attacchi crittografici basati sulla computazione quantistica.
    \item RSA a chiave post-quantistica resistente ai rumori: combina il cifrario RSA con tecniche di correzione degli errori per garantire una sicurezza a lungo termine contro gli attacchi crittografici basati sulla computazione quantistica.
    \item RSA a chiave ibrida resistente ai rumori: combina il cifrario RSA con algoritmi di correzione degli errori per ottenere un sistema crittografico efficiente e sicuro contro gli attacchi crittografici basati sulla computazione quantistica.
    \item RSA a chiave distribuita resistente ai rumori: suddivide la chiave privata tra più entità e utilizza tecniche di correzione degli errori per garantire una protezione affidabile contro gli attacchi crittografici basati sulla computazione quantistica.
    \item RSA a chiave cieca resistente ai rumori: consente a un'entità di cifrare i dati senza conoscere la chiave pubblica dell'altra entità e utilizza tecniche di correzione degli errori per garantire la privacy e la sicurezza dei dati.
    \item RSA a chiave condivisa resistente ai rumori: utilizza una chiave condivisa tra le entità e tecniche di correzione degli errori per cifrare e decifrare i messaggi, semplificando la gestione delle chiavi e migliorando le prestazioni del sistema.
    \item RSA a chiave zero-knowledge resistente ai rumori: consente a un'entità di dimostrare la conoscenza di una chiave privata senza rivelarla e utilizza tecniche di correzione degli errori per garantire la sicurezza e la privacy dei dati.
\end{itemize}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
\chapter{Il Problema del Logaritmo Discreto}

\section{Introduzione}
Il problema del logaritmo discreto è uno dei problemi fondamentali nella crittografia a chiave pubblica e nella teoria dei numeri. Esso costituisce la base di molti importanti algoritmi crittografici, come il crittosistema di Diffie-Hellman, il DSA (Digital Signature Algorithm) e i crittosistemi basati sulle curve ellittiche.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{img/logarithms.png}
    \caption{Confronto tra logaritmo continuo e logaritmo discreto \cite{stein2008}.}
    \label{fig:logarithms}
\end{figure}

\section{Fondamenti teoria dei gruppi}
Per comprendere il problema del logaritmo discreto, è necessario avere una conoscenza di base della teoria dei gruppi.

\subsection*{Gruppo}

Un gruppo \( (G, \cdot) \) è un insieme \( G \) di elementi con a un'operazione binaria \( \cdot \) che soddisfa le seguenti proprietà:

\begin{enumerate}
    \item \textbf{Chiusura}: \(\forall a, b \in G, \, \quad a \cdot b \in G.\)
    \item \textbf{Associatività}: \(\forall a, b, c \in G, \quad (a \cdot b) \cdot c = a \cdot (b \cdot c).\)
    \item \textbf{Elemento neutro}: \(\exists e \in G \quad tale \quad che \quad \forall a \in G, e \cdot a = a \cdot e = a.\)
    \item \textbf{Elemento inverso}: \(\forall a \in G, \quad \exists b \in G \quad tale \quad che \quad a \cdot b = b \cdot a = e.\)
\end{enumerate}

\subsection*{Gruppo Ciclico}

Un gruppo ciclico è un gruppo \( (G, \cdot) \) generato da un singolo elemento \( g \). Ogni elemento del gruppo può essere scritto come una potenza (o multiplo) di \( g \). Formalmente, un gruppo \( G \) è ciclico se esiste \( g \in G \) tale che
\[G = \langle g \rangle = \{ g^k \mid k \in \mathbb{Z} \}.\]

\subsection*{Gruppo Ciclico Finito}

Un gruppo ciclico finito è un gruppo ciclico \( (G, \cdot) \) con un numero finito di elementi. Se \( G \) è generato da \( g \), allora esiste un intero positivo \( n \) tale che gli elementi di \( G \) sono
\[\{e, g, g^2, g^3, \ldots, g^{n-1}\},\]
dove \( e \) è l'elemento neutro e \( g^n = e \). La cardinalità (o ordine) del gruppo ciclico finito è \( n \).

\section{Definizione Formale}
Sia $G$ un gruppo ciclico finito di ordine $n$, con generatore $g$. Per ogni elemento $h \in G$, esiste un unico intero $x$, con $0 \leq x < n$, tale che:
\[h = g^x\]

L'intero $x$ è chiamato logaritmo discreto di $h$ rispetto alla base $g$ nel gruppo $G$, e si indica con:
\[x = \log_g h\]

Il \textbf{problema del logaritmo discreto} consiste nel calcolare $x$ dati $g$, $h$ e $G$. 

\section{Proprietà e Applicazioni}
Il problema del logaritmo discreto gode di alcune importanti proprietà che lo rendono fondamentale nella crittografia:

\begin{itemize}
    \item Calcolare $g^x$ dato $g$ e $x$ è un'operazione \textbf{relativamente semplice }da eseguire in modo efficiente.
    \item Al contrario, calcolare $x$ dati $g$ e $g^x$ è un \textbf{problema computazionalmente difficile} per gruppi sufficientemente grandi.
    \item La \textbf{difficoltà del problema} dipende dalla dimensione del gruppo e dalla scelta del generatore $g$.
\end{itemize}

\section{Algoritmi di Calcolo}
Nonostante la difficoltà intrinseca del problema del logaritmo discreto, sono stati sviluppati diversi algoritmi per tentare di risolverlo in modo efficiente. Alcuni dei più noti includono:
\begin{itemize}
    \item \textbf{Algoritmo baby-step giant-step}: tecnica efficiente che riduce la complessità da esponenziale a radice quadrata, ma che richiede grande quantità di memoria, vedi \cite{silverman2009elliptic} e \cite{coron2011baby}.
    \item \textbf{Algoritmo rho di Pollard}: algoritmo probabilistico che sfrutta la ricerca di sequenze di esponenti nel gruppo, vedi \cite{nickerson2020collision}.
\end{itemize}

Tuttavia, per gruppi sufficientemente grandi, questi algoritmi non sono in grado di risolvere il problema del logaritmo discreto in tempi ragionevoli. Questa proprietà è fondamentale per garantire la sicurezza dei sistemi crittografici basati su tale problema.
%
%
%
%
%
%
%
%
%
%
%
%
%
%

%
%
%
%
%
%
%
%
%
%
%
%
\chapter{Firma Digitale}

\section{Introduzione}
La firma digitale è un meccanismo crittografico fondamentale per garantire l'autenticità, l'integrità e la non-ripudiabilità dei dati digitali. Essa svolge un ruolo analogo a quello della firma autografa nei documenti cartacei, ma sfrutta tecniche di crittografia a chiave pubblica per offrire maggiore sicurezza e verificabilità. I principali algoritmi utilizzati per la firma digitale sono il Digital Signature Algorithm (DSA) e il cifrario RSA.
\section{Funzioni Hash}
Le funzioni hash sono essenziali per il funzionamento delle firme digitali.

In questa sezione, si introducono i concetti chiave delle funzioni hash necessari per comprendere come esse siano utilizzate nella firma digitale.

\subsection*{Definizione di Funzione Hash Crittografica}
Le funzioni hash crittografiche sono un sottoinsieme specifico delle funzioni hash, progettate e analizzate per soddisfare determinati requisiti di sicurezza crittografica. 
Una funzione hash è una funzione matematica che mappa un input di lunghezza arbitraria a un output di lunghezza fissa, chiamato \textit{digest} o \textit{hash value}.

\textbf{Formalmente}: una funzione hash crittografica $H$ può essere definita come segue:
\[H: \{0,1\}^* \rightarrow \{0,1\}^n\]

dove $\{0,1\}^*$ rappresenta l'insieme di tutte le stringhe binarie di lunghezza arbitraria e $\{0,1\}^n$ rappresenta l'insieme delle stringhe binarie di lunghezza fissa $n$.

\subsection*{Proprietà Fondamentali}

Per essere utilizzata nella firma digitale, una funzione hash deve possedere le seguenti proprietà fondamentali:

\begin{itemize}
    \item \textbf{Resistenza alla preimmagine}: Dato un valore hash $h$, dovrebbe essere computazionalmente infeasible trovare un input $x$ tale che $H(x) = h$.
    \item \textbf{Resistenza alla seconda preimmagine}: Dato un input $x_1$, dovrebbe essere computazionalmente infeasible trovare un altro input $x_2$ tale che $x_1 \neq x_2$ e $H(x_1) = H(x_2)$.
    \item \textbf{Resistenza alle collisioni}: Dovrebbe essere computazionalmente infeasible trovare due input distinti $x_1$ e $x_2$ tali che $H(x_1) = H(x_2)$.
\end{itemize}

\subsection*{Funzioni Hash Crittografiche Comuni}
\begin{itemize}
    \item \textbf{MD5 (Message Digest Algorithm 5)}: una delle funzioni hash più conosciute, MD5 produce un output di 128 bit. Tuttavia, a causa di vulnerabilità crittografiche scoperte, MD5 non è più considerata sicura per molte applicazioni critiche.
    \item \textbf{SHA-1 (Secure Hash Algorithm 1)}: produce un output di 160 bit ed è stata ampiamente utilizzata in passato. Analogamente a MD5, ha subito critiche e attacchi, rendendola inadeguata per applicazioni sicure.
    \item \textbf{SHA-2 (Secure Hash Algorithm 2)}: una famiglia di funzioni hash che include SHA-224, SHA-256, SHA-384 e SHA-512, con numeri che indicano la dimensione dell'output in bit. SHA-2 è attualmente considerata sicura ed è ampiamente utilizzata in molte applicazioni crittografiche.
    \item \textbf{SHA-3 (Secure Hash Algorithm 3)}: la più recente famiglia di funzioni hash standardizzata dal NIST. SHA-3 è stata progettata come alternativa a SHA-2, con una struttura crittografica diversa basata su Keccak, offrendo robustezza contro una vasta gamma di attacchi.
\end{itemize}

\section{Firma Digitale con RSA}
Il cifrario RSA può essere utilizzato per realizzare un meccanismo di firma digitale robusto e sicuro, sfruttando le sue proprietà matematiche.

\subsection{Generazione della Firma Digitale con RSA}
Nel cifrario RSA, ogni utente ha una coppia di chiavi: una chiave pubblica $(e, n)$ e una chiave privata $d$, dove $n$ è il prodotto di due numeri primi $p$ e $q$, $e$ è l'esponente di cifratura e $d$ è l'esponente di decifratura tale che:
\[d \cdot e \equiv 1 \pmod{\phi(n)}\]
Per firmare un messaggio $m$, il mittente:

\begin{enumerate}
    \item Calcola l'impronta digitale $H(m)$ del messaggio $m$ utilizzando una funzione di hash crittografica.
    \item Cifra l'impronta digitale $H(m)$ con la chiave privata $d$, ottenendo la firma digitale $s$:
    \[ s \equiv H(m)^d \pmod{n}\]
\end{enumerate}

\subsection{Verifica della Firma Digitale con RSA}
Per verificare la firma digitale $s$, il destinatario:

\begin{enumerate}
    \item Calcola l'impronta digitale $H(m)$ del messaggio ricevuto $m$.
    \item Decifra la firma digitale $s$ con la chiave pubblica $(e, n)$ del mittente:
    \[v \equiv s^e \pmod{n}\]
    \item Se $v = H(m)$, la firma digitale è valida.
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{img/digital_signature_process.png}
    \caption{Processo di Firma Digitale dal libro \cite{stallings2011cryptography}}
    \label{fig:digital_signature_process}
\end{figure}

\section{Firma Digitale con DSA}
Il Digital Signature Algorithm (DSA) è uno standard per la firma digitale di documenti elettronici basato sul problema del logaritmo discreto.

\subsection{Generazione della Firma Digitale con DSA}
Siano $p$ un numero primo grande, $q$ un fattore primo di $p - 1$, e $g$ un generatore dell'ordine $q$ nel campo $\mathbb{Z}_p^*$. Sia $x$ la chiave privata del mittente e $y = g^x \bmod p$ la corrispondente chiave pubblica.

Per firmare un messaggio $m$, il mittente calcola un valore casuale $k$ coprime con $q$ e determina:

\begin{align*}
r &= (g^k \bmod p) \bmod q \\
s &= k^{-1}(H(m) + xr) \bmod q
\end{align*}

Dove $H(m)$ è l'impronta digitale del messaggio $m$ e $(k^{-1} \bmod q)$ è l'inverso moltiplicativo di $k$ modulo $q$. La firma digitale è la coppia $(r, s)$.

\subsection{Verifica della Firma Digitale con DSA}
La verifica della firma avviene calcolando:

\[
v = g^{H(m)}y^{rs} \bmod p \bmod q
\]

Se $v = r$, la firma è valida.

\section{Sicurezza e Utilizzo}
La sicurezza della firma digitale con DSA risiede nella difficoltà di calcolare il logaritmo discreto $x$ dato $g$ e $y$, mentre per RSA dipende dalla difficoltà di fattorizzare il modulo $n$. Inoltre, la funzione di hash crittografica deve essere resistente alle collisioni.

La firma digitale trova ampio utilizzo in diversi contesti per garantire l'autenticità, l'integrità e la non-ripudiabilità dei dati digitali. Alcune modalità d'utilizzo comuni includono:

\begin{itemize}
    \item Transazioni Elettroniche
    \item Certificazione di Documenti
    \item Protezione del Software
    \item Autenticazione dei Messaggi di Posta Elettronica
\end{itemize}

Queste sono solo alcune delle modalità d'utilizzo della firma digitale, che trova applicazione in molti altri contesti in cui è necessario garantire l'autenticità e l'integrità dei dati digitali. Standard come SSL/TLS, S/MIME e PGP incorporano meccanismi di firma digitale..
%
%
%
%
%
%
%
%
%
%
%
%
\chapter{Curve Ellittiche}
Le curve ellittiche sono insiemi di punti $(x, y)$ che soddisfano un'equazione di forma cubica: $y^2 = x^3 + ax + b$, dove $a$ e $b$ sono costanti. Le curve ellittiche hanno molte applicazioni in crittografia grazie alla loro proprietà di essere non solo additive ma anche moltiplicative.

\section{Definizione}

Una curva ellittica su un campo $K$ è l'insieme dei punti $(x, y)$ che soddisfano l'equazione:

\[y^2 = x^3 + ax + b\]

dove $a, b \in K$ e $4a^3 + 27b^2 \neq 0$. Il punto all'infinito $\mathcal{O}$ è incluso nella curva ellittica.

\section{Operazioni su Curve Ellittiche}

Le curve ellittiche supportano operazioni di somma e moltiplicazione tra punti. L'operazione di somma tra due punti $P$ e $Q$ su una curva ellittica restituisce un terzo punto $R$ che giace sulla stessa curva. L'operazione di moltiplicazione tra un punto $P$ e uno scalare $k$ restituisce un punto $Q$ che è la somma di $P$ con se stesso $k$ volte.

\section{Crittoanalisi delle Curve Ellittiche}

Le curve ellittiche sono utilizzate in crittografia per la loro resistenza a diverse tecniche di crittoanalisi, come l'attacco brute-force e l'attacco conosciuto come "baby-step giant-step". Tuttavia, la sicurezza delle curve ellittiche dipende dalla scelta dei parametri e dalla corretta implementazione degli algoritmi crittografici.

\section{Applicazioni delle Curve Ellittiche}

Le curve ellittiche sono utilizzate in diversi protocolli crittografici, come il Diffie-Hellman ellittico (ECDH) per lo scambio di chiavi segrete, l'algoritmo di firma digitale ellittica (ECDSA) per la firma digitale e il crittosistema di ElGamal ellittico per la crittografia a chiave pubblica. Le curve ellittiche sono anche utilizzate in applicazioni come la crittografia di dispositivi mobili e la sicurezza delle transazioni finanziarie.

\nocite{*}
\bibliographystyle{plain}
\bibliography{report-template}

\end{document}
